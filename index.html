<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Drunk Bike</title>

<script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>
<script src="https://d309knd7es5f10.cloudfront.net/zim_6.8.1.js"></script>

<script src="https://d309knd7es5f10.cloudfront.net/Box2dWeb-2.1.a.3.min.js"></script>
<script src="libs/physics_0.1.2.js"></script><!-- helper code for box2D -->

<style>body {background-color:#999}</style>

<script>

var frame = new zim.Frame("fit", 1000, 800, "#222");
frame.on("ready", function() {
	zog("ready from ZIM Frame");

	var stage = frame.stage;
	var stageW = frame.width;
	var stageH = frame.height;

	var borders = {x:0, y:0, width:stageW, height:stageH}; //Creating a border around the play area
	var physics = new zim.Physics(frame, borders, 6); //Setting gravity to a value of 6

	physics.debug(); //Turns on debug mode

	// INITIAL VARS
	// here we specify width, height, radius
	// so we can use both for Box2D shapes and ZIM shapes
	var circleR = 50;
	var boxW = 50;
	var boxH = 50;

	//Creating the physics objects, a square for variability, a circle for the users head and another circle to act a joint
	var bbox = physics.makeRectangle({
		width: boxW,
		height: boxH,
		dynamic: true,
		friction: 0,
		density: 0.5
	});
    var circBody1 = physics.makeCircle({
		dynamic:true,
		radius:circleR,
		angular:.1,
		linear:.1
	});
    var circBody2= physics.makeCircle({
		dynamic:false,
		radius:circleR,
		angular:.1,
		linear:.1
	});

    circBody1.x = 500;
    circBody1.y = 500;

    circBody2.x = 500;
    circBody2.y = 800;

	bbox.x = 600;
	bbox.y = 500;

    let circ1 = new Circle(circleR, frame.blue).addTo(stage).pos(circBody1.x, circBody1.y);
    let circ2 = new Circle(circleR, frame.red).addTo(stage).pos(circBody2.x, circBody2.y);

	//Adding Zim objects to mask the physics circles so they can be visible to users
    physics.addMap(circBody1, circ1);
    physics.addMap(circBody2, circ2);

	//This creats a joint between a ball that acts as an anchor in the middle of the screen and the characters head
    var distanceJointDef = new b2DistanceJointDef();
    distanceJointDef.Initialize(circBody1, circBody2, circBody1.GetWorldCenter(), circBody2.GetWorldCenter());
    physics.world.CreateJoint(distanceJointDef);

	// This joint is between the characters head and an invisible box (invisible to the uses)
	// It is used to add variability and make it more difficult for a user to predict the riders movement
	var boxJointDef = new b2DistanceJointDef();
	boxJointDef.Initialize(circBody1, bbox, circBody1.GetWorldCenter(), bbox.GetWorldCenter());
	physics.world.CreateJoint(boxJointDef);

	//Initial variables for the game
	const leanLeft = 83;
	const leanRight = 75;
	const peddleLeft = 88;
	const peddleRight = 77;
	const peddleCombo = [peddleLeft, peddleRight];

	let successfulPeddle;
	let peddleBuffer = [0,0];
	let momentum = 1;
	let distance = 0;
	let alternatePeddleForce = Math.floor(Math.random() * 4) + 1;

	//A label to track the users distance and eventually display the game over message
	var distanceLabel = new Label({
       text:`Distance: ${distance}m`,
       size:40,
       font:"courier",
       color:frame.pink,
    })
        .centerReg(stage)
        .mov(-300,-300);

	//Event listener for users' keyboard inputs so they can be handled
	window.addEventListener('keyup', checkInput);

	//Function to taking in user inputs and applying corresponding forces to the game physics
	function checkInput(e) {
		if(peddleBuffer.length > 1) peddleBuffer.shift();
		peddleBuffer.push(e.keyCode);
		// console.log(peddleBuffer); //Log for debugging the buffer of user inputs
		switch(e.keyCode) {
			case leanLeft: leftForce();
				break;
			case leanRight: rightForce();
				break;
			case peddleLeft: checkPeddle(peddleBuffer);
				break;
			case peddleRight: checkPeddle(peddleBuffer);
				break;
		}
	}

	function checkPeddle(buffer) {
		//console.log(buffer); //Another log for buffer debugging
		// successfulPeddle = peddleCombo.every((val) => buffer.includes(val) ? buffer.shift() : false); //Initial buffer testing function, but it didn't work correctly
		//Testing to see if the peddleBuffer variable thats passed into this function has specifically both peddle inputs in it, so the users last 2 inputs would have to be x and m in the peddleBuffer array
		if (buffer.indexOf(peddleLeft) !== -1 && buffer.indexOf(peddleRight) !== -1) {
			upForce(); //A function which applies an upward force to the character in the game
			distance+=Math.round(momentum/50); //Calculating the distance the user biked which is based on their momentum
			if(momentum < 120) momentum+=4; //4 is added to the bikers momentum on each successful peddle
			//console.log(momentum); //debugging the momentum
		} else {
			momentum < 0 ? 0 : momentum-=6; //If the buffer has only 1 peddle key in it then this is run where we subtract an amount from the users momentum making it more difficult to rack up distance, penalizing mistakes
			console.log(`Momentum after subtractiong: ${momentum}`);
		}
	}

	function randomPeddleForce() {
		return alternatePeddleForce = Math.floor(Math.random() * 6) + 2;
	}

	function upForce() {
		alternatePeddleForce = alternatePeddleForce > 0 ? -Math.abs(randomPeddleForce()) : Math.abs(randomPeddleForce());
		circBody1.ApplyImpulse(new b2Vec2(alternatePeddleForce, -18), circBody1.GetWorldCenter());
		console.log(`Alternating peddle force: ${alternatePeddleForce}`);
	}

	function rightForce() {
		circBody1.ApplyImpulse(new b2Vec2(10, 0), circBody1.GetWorldCenter());
	}

	function leftForce() {
		circBody1.ApplyImpulse(new b2Vec2(-10, 0), circBody1.GetWorldCenter());
	}

	function hasFallen() {
		if (circBody1.y > 650) { //Check to see if the head of the rider has dipped below 650 on the Y axis of the game
			console.log("Now its ended");
			circ2.removeFrom(stage);
			window.removeEventListener('keyup', checkInput);
			Ticker.removeAll();
			distanceLabel.text = `Game Over! You Traveled ${distance}m`;
			stage.update();
		}
	}

	function setBoxDensity(boxName, density) {
		boxName.m_fixtureList.SetDensity(density); //After reseting the density we have to recalculate the mass for it to take effect
		boxName.ResetMassData();
	}

	function checkDistance() {
		if (distance >= 75 && distance < 125) {
			setBoxDensity(bbox, 0.75);
		} else if (distance >= 200 && distance < 250) {
			setBoxDensity(bbox, 1);
		} else if (distance >= 325 && distance < 400){
			setBoxDensity(bbox, 1.25);
		} else if (distance >= 475) {
			setBoxDensity(bbox, 1.5);
		}
	}

    Ticker.add(function(){
		checkDistance(); //Checks how far the user has come and adjusts the difficulty
		distanceLabel.text = `Distance: ${distance}m`; //Update the distance display
		hasFallen(); //Check to see if the user has fallen and end the game
        stage.update();
    });

	stage.update();
});

</script>
</head>

<body>
</body>
</html>
