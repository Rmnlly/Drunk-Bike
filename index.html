<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Drunk Bike</title>

<script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>
<script src="https://d309knd7es5f10.cloudfront.net/zim_6.8.1.js"></script>

<script src="https://d309knd7es5f10.cloudfront.net/Box2dWeb-2.1.a.3.min.js"></script>
<script src="libs/physics_0.1.2.js"></script><!-- helper code for box2D -->

<style>body {background-color:#999}</style>

<script>

var frame = new zim.Frame("fit", 1000, 800, "#222");
frame.on("ready", function() {
	zog("ready from ZIM Frame");

	var stage = frame.stage;
	var stageW = frame.width;
	var stageH = frame.height;


	var borders = {x:0, y:0, width:stageW, height:stageH};

	var physics = new zim.Physics(frame, borders, 6);

	physics.debug();

	// INITIAL VARS
	// here we specify width, height, radius
	// so we can use both for Box2D shapes and ZIM shapes
	var circleR = 50;
	var boxW = 50;
	var boxH = 50;

	//Creating the small box
	var bbox = physics.makeRectangle({
		width: boxW,
		height: boxH,
		dynamic: true,
		friction: 0,
		density: 0.5
	});

    var circBody1 = physics.makeCircle({
		dynamic:true,
		radius:circleR,
		angular:.1,
		linear:.1
	});
    var circBody2= physics.makeCircle({
		dynamic:false,
		radius:circleR,
		angular:.1,
		linear:.1
	});

    circBody1.x = 500;
    circBody1.y = 500;

    circBody2.x = 500;
    circBody2.y = 800;

	bbox.x = 600;
	bbox.y = 500;

    let circ1 = new Circle(circleR, frame.blue).addTo(stage).pos(circBody1.x, circBody1.y);

    let circ2 = new Circle(circleR, frame.red).addTo(stage).pos(circBody2.x, circBody2.y);

    physics.addMap(circBody1, circ1);
    physics.addMap(circBody2, circ2);

    let speed;

    var distanceJointDef = new b2DistanceJointDef();
    // two bodies followed by joint end positions
    distanceJointDef.Initialize(circBody1, circBody2, circBody1.GetWorldCenter(), circBody2.GetWorldCenter());
    physics.world.CreateJoint(distanceJointDef);

	var boxJointDef = new b2DistanceJointDef();
	boxJointDef.Initialize(circBody1, bbox, circBody1.GetWorldCenter(), bbox.GetWorldCenter());
	physics.world.CreateJoint(boxJointDef);

	const leanLeft = 83;
	const leanRight = 75;
	const peddleLeft = 88;
	const peddleRight = 77;
	const peddleCombo = [peddleLeft, peddleRight];
	let successfulPeddle;
	let peddleBuffer = [0,0];
	let momentum = 0;
	let distance = 0;
	let alternatePeddleForce = Math.floor(Math.random() * 4) + 1;

	var distanceLabel = new Label({
       text:`Distance: ${distance}m`,
       size:40,
       font:"courier",
       color:frame.pink,
    })
        .centerReg(stage)
        .mov(-300,-300);

	window.addEventListener('keyup', checkInput);

	function checkInput(e) {
		if(peddleBuffer.length > 1) peddleBuffer.shift();
		peddleBuffer.push(e.keyCode);
		console.log(peddleBuffer);
		switch(e.keyCode) {
			case leanLeft: leftForce();
				break;
			case leanRight: rightForce();
				break;
			case peddleLeft: checkPeddle(peddleBuffer);
				break;
			case peddleRight: checkPeddle(peddleBuffer);
				break;
		}
	}

	function checkPeddle(buffer) {
		console.log(buffer);
		// successfulPeddle = peddleCombo.every((val) => buffer.includes(val) ? buffer.shift() : false);
		if (buffer.indexOf(peddleLeft) !== -1 && buffer.indexOf(peddleRight) !== -1) {
			upForce();
			distance+=Math.round(momentum/50);
			if(momentum < 100) momentum+=4;
			//counter = 0;
			console.log(momentum);
		} else {
			if(momentum > 0) momentum-=10; //Make a default of 0
			console.log(momentum);
		}
	}

	function randomPeddleForce() {
		return alternatePeddleForce = Math.floor(Math.random() * 6) + 1;
	}

	function upForce() {
		alternatePeddleForce = alternatePeddleForce > 0 ? -Math.abs(randomPeddleForce()) : Math.abs(randomPeddleForce());
		circBody1.ApplyImpulse(new b2Vec2(alternatePeddleForce, -18), circBody1.GetWorldCenter());
		console.log(alternatePeddleForce);
	}
	function rightForce() {
		circBody1.ApplyImpulse(new b2Vec2(10, 0), circBody1.GetWorldCenter());
	}
	function leftForce() {
		circBody1.ApplyImpulse(new b2Vec2(-10, 0), circBody1.GetWorldCenter());
	}

	function hasFallen() {
		if (circBody1.y > 650) { //Check to see if the head of the rider has dipped below 650 on the Y axis of the game
			console.log("Now its ended");
			circ2.removeFrom(stage);
			window.removeEventListener('keyup', checkInput);
			Ticker.removeAll();
			distanceLabel.text = `Game Over! You Traveled ${distance}m`;
			stage.update();
		}
	}

	function setBoxDensity(boxName,density) {
		boxName.m_fixtureList.SetDensity(density); //After reseting the density we have to recalculate the mass for it to take effect
		boxName.ResetMassData();
	}

	function checkDistance() {
		if (distance >= 75 && distance < 125) {
			setBoxDensity(bbox, 0.75);
		} else if (distance >= 200 && distance < 250) {
			setBoxDensity(bbox, 1);
		} else if (distance >= 325 && distance < 400){
			setBoxDensity(bbox, 1.25);
		} else if (distance >= 475) {
			setBoxDensity(bbox, 1.5);
		}
		console.log(`Box Density: ${bbox}`);
	}

	//Old speed function
	// var label = new Label({
    //    text:speed,
    //    size:60,
    //    font:"courier",
    //    color:frame.pink,
    // })
    //     .centerReg(stage)
    //     .mov(-300,-300);
	// //These in the ticker
	// speed = Math.sqrt(Math.pow(circBody1.GetLinearVelocity().x, 2) + Math.pow(circBody1.GetLinearVelocity().y, 2));
	// speed = Math.round(speed * 100)/100;
	// label.text = speed;

    Ticker.add(function(){
		checkDistance(); //Checks how far the user has come and adjusts the difficulty
		distanceLabel.text = `Distance: ${distance}m`; //Update the distance display
		hasFallen(); //Check to see if the user has fallen and end the game
        stage.update();
    });

	stage.update();
});

</script>
</head>

<body>
</body>
</html>
